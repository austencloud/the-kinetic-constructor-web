// PropPlacementManager.ts
import { DefaultPropPositioner } from './DefaultPropPositioner';
import { BetaPropPositioner } from './BetaPropPositioner';
import type { PictographData } from '$lib/types/PictographData';
import type { PictographChecker } from '$lib/components/Pictograph/PictographChecker';
import type { GridData } from '$lib/components/objects/Grid/GridData';
import type { PropData } from '$lib/components/objects/Prop/PropData';

export class PropPlacementManager {
    public defaultPositioner: DefaultPropPositioner;
    private betaPositioner: BetaPropPositioner;
    private checker: PictographChecker;
    public ready: Promise<void>;
    private resolveReady!: () => void;
    private rejectReady!: (reason?: any) => void;

    constructor(
        pictographData: PictographData,
        gridData: GridData | null,
        checker: PictographChecker
    ) {
        // if grid data is null when passed in, throw an error
        if (!gridData) {
            console.error('‚ùå PropPlacementManager: No grid data provided');
            throw new Error('Grid data is required to initialize PropPlacementManager');
        }
        
        const gridMode = pictographData?.gridMode ?? 'diamond';
        console.log(`üèóÔ∏è PropPlacementManager: Creating with grid mode ${gridMode}`);
        
        this.ready = new Promise<void>((resolve, reject) => {
            this.resolveReady = resolve;
            this.rejectReady = reject;
        });
        
        try {
            this.defaultPositioner = new DefaultPropPositioner(gridData, gridMode);
            this.betaPositioner = new BetaPropPositioner(pictographData);
            this.checker = checker;
            
            // Log the available grid points
            console.log(`üìä PropPlacementManager: Init with ${
                Object.keys(gridData.allHandPointsNormal || {}).length
            } normal hand points`);
            
            // Initialize is complete
            this.resolveReady();
        } catch (error) {
            console.error('‚ùå PropPlacementManager: Initialization failed', error);
            this.rejectReady(error);
            throw error;
        }
    }

    public updatePropPlacement(props: PropData[]): PropData[] {
        console.log(`üîÑ PropPlacementManager: Updating placement for ${props.length} props`);
        
        if (!props.length) {
            console.warn('‚ö†Ô∏è PropPlacementManager: No props provided to updatePropPlacement');
            return props;
        }
        
        // Log the props before positioning for debugging
        props.forEach(prop => {
            console.log(`üìä Before positioning: ${prop.color} prop at (${prop.coords.x}, ${prop.coords.y}), loc=${prop.loc}`);
        });
        
        // Apply default positioning
        props.forEach((prop) => {
            if (!prop.loc) {
                console.error(`‚ùå PropPlacementManager: Prop missing location data:`, prop.id);
                return;
            }
            
            this.defaultPositioner.setToDefaultPosition(prop);
            console.log(`üìå Default Positioner Set for ${prop.id} at (${prop.coords.x}, ${prop.coords.y})`);
        });

        // Apply beta positioning if needed
        if (this.checker.endsWithBeta()) {
            console.log("üîÑ Applying beta positioning adjustments");
            this.betaPositioner.reposition(props);
            props.forEach((prop) => console.log(`üöÄ Beta Positioner Set for ${prop.id} at (${prop.coords.x}, ${prop.coords.y})`));
        }

        // Validate positions
        this.validatePropPositions(props);

        return props;
    }
    
    private validatePropPositions(props: PropData[]): void {
        const invalidProps = props.filter(p => 
            !p.coords || (p.coords.x === 0 && p.coords.y === 0)
        );
        
        if (invalidProps.length > 0) {
            console.error(`‚ùå PropPlacementManager: ${invalidProps.length} props still at (0,0) after placement`);
            
            // Fix any invalid positions with fallback
            invalidProps.forEach(prop => {
                console.log(`üîß Fixing invalid position for ${prop.color} prop`);
                prop.coords = { x: 475, y: 475 }; // Center fallback
            });
        } else {
            console.log('‚úÖ PropPlacementManager: All props successfully positioned');
        }
    }
}